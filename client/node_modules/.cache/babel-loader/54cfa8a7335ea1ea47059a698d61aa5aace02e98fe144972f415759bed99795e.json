{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsClient = void 0;\nconst awsrequestsigner_1 = require(\"./awsrequestsigner\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */\nclass AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n  /**\n   * Instantiates an AwsClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * An error is thrown if the credential is not a valid AWS credential.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    super(options, additionalOptions);\n    this.environmentId = options.credential_source.environment_id;\n    // This is only required if the AWS region is not available in the\n    // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n    this.regionUrl = options.credential_source.region_url;\n    // This is only required if AWS security credentials are not available in\n    // environment variables.\n    this.securityCredentialsUrl = options.credential_source.url;\n    this.regionalCredVerificationUrl = options.credential_source.regional_cred_verification_url;\n    this.imdsV2SessionTokenUrl = options.credential_source.imdsv2_session_token_url;\n    this.awsRequestSigner = null;\n    this.region = '';\n    // data validators\n    this.validateEnvironmentId();\n    this.validateMetadataServerURLs();\n  }\n  validateEnvironmentId() {\n    var _a;\n    const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n    if (!match || !this.regionalCredVerificationUrl) {\n      throw new Error('No valid AWS \"credential_source\" provided');\n    } else if (parseInt(match[2], 10) !== 1) {\n      throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n    }\n  }\n  validateMetadataServerURLs() {\n    this.validateMetadataURL(this.regionUrl, 'region_url');\n    this.validateMetadataURL(this.securityCredentialsUrl, 'url');\n    this.validateMetadataURL(this.imdsV2SessionTokenUrl, 'imdsv2_session_token_url');\n  }\n  validateMetadataURL(value, prop) {\n    if (!value) return;\n    const url = new URL(value);\n    if (url.hostname !== AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS && url.hostname !== `[${AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS}]`) {\n      throw new RangeError(`Invalid host \"${url.hostname}\" for \"${prop}\". Expecting ${AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS} or ${AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS}.`);\n    }\n  }\n  /**\n   * Triggered when an external subject token is needed to be exchanged for a\n   * GCP access token via GCP STS endpoint.\n   * This uses the `options.credential_source` object to figure out how\n   * to retrieve the token using the current environment. In this case,\n   * this uses a serialized AWS signed request to the STS GetCallerIdentity\n   * endpoint.\n   * The logic is summarized as:\n   * 1. If imdsv2_session_token_url is provided in the credential source, then\n   *    fetch the aws session token and include it in the headers of the\n   *    metadata requests. This is a requirement for IDMSv2 but optional\n   *    for IDMSv1.\n   * 2. Retrieve AWS region from availability-zone.\n   * 3a. Check AWS credentials in environment variables. If not found, get\n   *     from security-credentials endpoint.\n   * 3b. Get AWS credentials from security-credentials endpoint. In order\n   *     to retrieve this, the AWS role needs to be determined by calling\n   *     security-credentials endpoint without any argument. Then the\n   *     credentials can be retrieved via: security-credentials/role_name\n   * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n   * 5. Inject x-goog-cloud-target-resource into header and serialize the\n   *    signed request. This will be the subject-token to pass to GCP STS.\n   * @return A promise that resolves with the external subject token.\n   */\n  async retrieveSubjectToken() {\n    // Initialize AWS request signer if not already initialized.\n    if (!this.awsRequestSigner) {\n      const metadataHeaders = {};\n      if (this.imdsV2SessionTokenUrl) {\n        metadataHeaders['x-aws-ec2-metadata-token'] = await this.getImdsV2SessionToken();\n      }\n      this.region = await this.getAwsRegion(metadataHeaders);\n      this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {\n        // Check environment variables for permanent credentials first.\n        // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n        if (process.env['AWS_ACCESS_KEY_ID'] && process.env['AWS_SECRET_ACCESS_KEY']) {\n          return {\n            accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n            secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n            // This is normally not available for permanent credentials.\n            token: process.env['AWS_SESSION_TOKEN']\n          };\n        }\n        // Since the role on a VM can change, we don't need to cache it.\n        const roleName = await this.getAwsRoleName(metadataHeaders);\n        // Temporary credentials typically last for several hours.\n        // Expiration is returned in response.\n        // Consider future optimization of this logic to cache AWS tokens\n        // until their natural expiration.\n        const awsCreds = await this.getAwsSecurityCredentials(roleName, metadataHeaders);\n        return {\n          accessKeyId: awsCreds.AccessKeyId,\n          secretAccessKey: awsCreds.SecretAccessKey,\n          token: awsCreds.Token\n        };\n      }, this.region);\n    }\n    // Generate signed request to AWS STS GetCallerIdentity API.\n    // Use the required regional endpoint. Otherwise, the request will fail.\n    const options = await this.awsRequestSigner.getRequestOptions({\n      url: this.regionalCredVerificationUrl.replace('{region}', this.region),\n      method: 'POST'\n    });\n    // The GCP STS endpoint expects the headers to be formatted as:\n    // [\n    //   {key: 'x-amz-date', value: '...'},\n    //   {key: 'Authorization', value: '...'},\n    //   ...\n    // ]\n    // And then serialized as:\n    // encodeURIComponent(JSON.stringify({\n    //   url: '...',\n    //   method: 'POST',\n    //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n    // }))\n    const reformattedHeader = [];\n    const extendedHeaders = Object.assign({\n      // The full, canonical resource name of the workload identity pool\n      // provider, with or without the HTTPS prefix.\n      // Including this header as part of the signature is recommended to\n      // ensure data integrity.\n      'x-goog-cloud-target-resource': this.audience\n    }, options.headers);\n    // Reformat header to GCP STS expected format.\n    for (const key in extendedHeaders) {\n      reformattedHeader.push({\n        key,\n        value: extendedHeaders[key]\n      });\n    }\n    // Serialize the reformatted signed request.\n    return encodeURIComponent(JSON.stringify({\n      url: options.url,\n      method: options.method,\n      headers: reformattedHeader\n    }));\n  }\n  /**\n   * @return A promise that resolves with the IMDSv2 Session Token.\n   */\n  async getImdsV2SessionToken() {\n    const opts = {\n      url: this.imdsV2SessionTokenUrl,\n      method: 'PUT',\n      responseType: 'text',\n      headers: {\n        'x-aws-ec2-metadata-token-ttl-seconds': '300'\n      }\n    };\n    const response = await this.transporter.request(opts);\n    return response.data;\n  }\n  /**\n   * @param headers The headers to be used in the metadata request.\n   * @return A promise that resolves with the current AWS region.\n   */\n  async getAwsRegion(headers) {\n    // Priority order for region determination:\n    // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n    if (process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION']) {\n      return process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'];\n    }\n    if (!this.regionUrl) {\n      throw new Error('Unable to determine AWS region due to missing ' + '\"options.credential_source.region_url\"');\n    }\n    const opts = {\n      url: this.regionUrl,\n      method: 'GET',\n      responseType: 'text',\n      headers: headers\n    };\n    const response = await this.transporter.request(opts);\n    // Remove last character. For example, if us-east-2b is returned,\n    // the region would be us-east-2.\n    return response.data.substr(0, response.data.length - 1);\n  }\n  /**\n   * @param headers The headers to be used in the metadata request.\n   * @return A promise that resolves with the assigned role to the current\n   *   AWS VM. This is needed for calling the security-credentials endpoint.\n   */\n  async getAwsRoleName(headers) {\n    if (!this.securityCredentialsUrl) {\n      throw new Error('Unable to determine AWS role name due to missing ' + '\"options.credential_source.url\"');\n    }\n    const opts = {\n      url: this.securityCredentialsUrl,\n      method: 'GET',\n      responseType: 'text',\n      headers: headers\n    };\n    const response = await this.transporter.request(opts);\n    return response.data;\n  }\n  /**\n   * Retrieves the temporary AWS credentials by calling the security-credentials\n   * endpoint as specified in the `credential_source` object.\n   * @param roleName The role attached to the current VM.\n   * @param headers The headers to be used in the metadata request.\n   * @return A promise that resolves with the temporary AWS credentials\n   *   needed for creating the GetCallerIdentity signed request.\n   */\n  async getAwsSecurityCredentials(roleName, headers) {\n    const response = await this.transporter.request({\n      url: `${this.securityCredentialsUrl}/${roleName}`,\n      responseType: 'json',\n      headers: headers\n    });\n    return response.data;\n  }\n}\nexports.AwsClient = AwsClient;\nAwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = '169.254.169.254';\nAwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = 'fd00:ec2::254';","map":{"version":3,"names":["Object","defineProperty","exports","value","AwsClient","awsrequestsigner_1","require","baseexternalclient_1","BaseExternalAccountClient","constructor","options","additionalOptions","environmentId","credential_source","environment_id","regionUrl","region_url","securityCredentialsUrl","url","regionalCredVerificationUrl","regional_cred_verification_url","imdsV2SessionTokenUrl","imdsv2_session_token_url","awsRequestSigner","region","validateEnvironmentId","validateMetadataServerURLs","_a","match","Error","parseInt","validateMetadataURL","prop","URL","hostname","AWS_EC2_METADATA_IPV4_ADDRESS","AWS_EC2_METADATA_IPV6_ADDRESS","RangeError","retrieveSubjectToken","metadataHeaders","getImdsV2SessionToken","getAwsRegion","AwsRequestSigner","process","env","accessKeyId","secretAccessKey","token","roleName","getAwsRoleName","awsCreds","getAwsSecurityCredentials","AccessKeyId","SecretAccessKey","Token","getRequestOptions","replace","method","reformattedHeader","extendedHeaders","assign","audience","headers","key","push","encodeURIComponent","JSON","stringify","opts","responseType","response","transporter","request","data","substr","length"],"sources":["/Users/kamilgeagea/Developer/competitions/conuhacks-client/node_modules/google-auth-library/build/src/auth/awsclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AwsClient = void 0;\nconst awsrequestsigner_1 = require(\"./awsrequestsigner\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */\nclass AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates an AwsClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid AWS credential.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super(options, additionalOptions);\n        this.environmentId = options.credential_source.environment_id;\n        // This is only required if the AWS region is not available in the\n        // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n        this.regionUrl = options.credential_source.region_url;\n        // This is only required if AWS security credentials are not available in\n        // environment variables.\n        this.securityCredentialsUrl = options.credential_source.url;\n        this.regionalCredVerificationUrl =\n            options.credential_source.regional_cred_verification_url;\n        this.imdsV2SessionTokenUrl =\n            options.credential_source.imdsv2_session_token_url;\n        this.awsRequestSigner = null;\n        this.region = '';\n        // data validators\n        this.validateEnvironmentId();\n        this.validateMetadataServerURLs();\n    }\n    validateEnvironmentId() {\n        var _a;\n        const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n        if (!match || !this.regionalCredVerificationUrl) {\n            throw new Error('No valid AWS \"credential_source\" provided');\n        }\n        else if (parseInt(match[2], 10) !== 1) {\n            throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n        }\n    }\n    validateMetadataServerURLs() {\n        this.validateMetadataURL(this.regionUrl, 'region_url');\n        this.validateMetadataURL(this.securityCredentialsUrl, 'url');\n        this.validateMetadataURL(this.imdsV2SessionTokenUrl, 'imdsv2_session_token_url');\n    }\n    validateMetadataURL(value, prop) {\n        if (!value)\n            return;\n        const url = new URL(value);\n        if (url.hostname !== AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS &&\n            url.hostname !== `[${AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS}]`) {\n            throw new RangeError(`Invalid host \"${url.hostname}\" for \"${prop}\". Expecting ${AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS} or ${AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS}.`);\n        }\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this uses a serialized AWS signed request to the STS GetCallerIdentity\n     * endpoint.\n     * The logic is summarized as:\n     * 1. If imdsv2_session_token_url is provided in the credential source, then\n     *    fetch the aws session token and include it in the headers of the\n     *    metadata requests. This is a requirement for IDMSv2 but optional\n     *    for IDMSv1.\n     * 2. Retrieve AWS region from availability-zone.\n     * 3a. Check AWS credentials in environment variables. If not found, get\n     *     from security-credentials endpoint.\n     * 3b. Get AWS credentials from security-credentials endpoint. In order\n     *     to retrieve this, the AWS role needs to be determined by calling\n     *     security-credentials endpoint without any argument. Then the\n     *     credentials can be retrieved via: security-credentials/role_name\n     * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n     * 5. Inject x-goog-cloud-target-resource into header and serialize the\n     *    signed request. This will be the subject-token to pass to GCP STS.\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        // Initialize AWS request signer if not already initialized.\n        if (!this.awsRequestSigner) {\n            const metadataHeaders = {};\n            if (this.imdsV2SessionTokenUrl) {\n                metadataHeaders['x-aws-ec2-metadata-token'] =\n                    await this.getImdsV2SessionToken();\n            }\n            this.region = await this.getAwsRegion(metadataHeaders);\n            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {\n                // Check environment variables for permanent credentials first.\n                // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n                if (process.env['AWS_ACCESS_KEY_ID'] &&\n                    process.env['AWS_SECRET_ACCESS_KEY']) {\n                    return {\n                        accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n                        secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n                        // This is normally not available for permanent credentials.\n                        token: process.env['AWS_SESSION_TOKEN'],\n                    };\n                }\n                // Since the role on a VM can change, we don't need to cache it.\n                const roleName = await this.getAwsRoleName(metadataHeaders);\n                // Temporary credentials typically last for several hours.\n                // Expiration is returned in response.\n                // Consider future optimization of this logic to cache AWS tokens\n                // until their natural expiration.\n                const awsCreds = await this.getAwsSecurityCredentials(roleName, metadataHeaders);\n                return {\n                    accessKeyId: awsCreds.AccessKeyId,\n                    secretAccessKey: awsCreds.SecretAccessKey,\n                    token: awsCreds.Token,\n                };\n            }, this.region);\n        }\n        // Generate signed request to AWS STS GetCallerIdentity API.\n        // Use the required regional endpoint. Otherwise, the request will fail.\n        const options = await this.awsRequestSigner.getRequestOptions({\n            url: this.regionalCredVerificationUrl.replace('{region}', this.region),\n            method: 'POST',\n        });\n        // The GCP STS endpoint expects the headers to be formatted as:\n        // [\n        //   {key: 'x-amz-date', value: '...'},\n        //   {key: 'Authorization', value: '...'},\n        //   ...\n        // ]\n        // And then serialized as:\n        // encodeURIComponent(JSON.stringify({\n        //   url: '...',\n        //   method: 'POST',\n        //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        // }))\n        const reformattedHeader = [];\n        const extendedHeaders = Object.assign({\n            // The full, canonical resource name of the workload identity pool\n            // provider, with or without the HTTPS prefix.\n            // Including this header as part of the signature is recommended to\n            // ensure data integrity.\n            'x-goog-cloud-target-resource': this.audience,\n        }, options.headers);\n        // Reformat header to GCP STS expected format.\n        for (const key in extendedHeaders) {\n            reformattedHeader.push({\n                key,\n                value: extendedHeaders[key],\n            });\n        }\n        // Serialize the reformatted signed request.\n        return encodeURIComponent(JSON.stringify({\n            url: options.url,\n            method: options.method,\n            headers: reformattedHeader,\n        }));\n    }\n    /**\n     * @return A promise that resolves with the IMDSv2 Session Token.\n     */\n    async getImdsV2SessionToken() {\n        const opts = {\n            url: this.imdsV2SessionTokenUrl,\n            method: 'PUT',\n            responseType: 'text',\n            headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '300' },\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the current AWS region.\n     */\n    async getAwsRegion(headers) {\n        // Priority order for region determination:\n        // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n        if (process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION']) {\n            return (process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION']);\n        }\n        if (!this.regionUrl) {\n            throw new Error('Unable to determine AWS region due to missing ' +\n                '\"options.credential_source.region_url\"');\n        }\n        const opts = {\n            url: this.regionUrl,\n            method: 'GET',\n            responseType: 'text',\n            headers: headers,\n        };\n        const response = await this.transporter.request(opts);\n        // Remove last character. For example, if us-east-2b is returned,\n        // the region would be us-east-2.\n        return response.data.substr(0, response.data.length - 1);\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the assigned role to the current\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\n     */\n    async getAwsRoleName(headers) {\n        if (!this.securityCredentialsUrl) {\n            throw new Error('Unable to determine AWS role name due to missing ' +\n                '\"options.credential_source.url\"');\n        }\n        const opts = {\n            url: this.securityCredentialsUrl,\n            method: 'GET',\n            responseType: 'text',\n            headers: headers,\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * Retrieves the temporary AWS credentials by calling the security-credentials\n     * endpoint as specified in the `credential_source` object.\n     * @param roleName The role attached to the current VM.\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the temporary AWS credentials\n     *   needed for creating the GetCallerIdentity signed request.\n     */\n    async getAwsSecurityCredentials(roleName, headers) {\n        const response = await this.transporter.request({\n            url: `${this.securityCredentialsUrl}/${roleName}`,\n            responseType: 'json',\n            headers: headers,\n        });\n        return response.data;\n    }\n}\nexports.AwsClient = AwsClient;\nAwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = '169.254.169.254';\nAwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = 'fd00:ec2::254';\n//# sourceMappingURL=awsclient.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}