{"ast":null,"code":"module.exports = {\n  compareTwoStrings: compareTwoStrings,\n  findBestMatch: findBestMatch\n};\nfunction compareTwoStrings(first, second) {\n  first = first.replace(/\\s+/g, '');\n  second = second.replace(/\\s+/g, '');\n  if (first === second) return 1; // identical or empty\n  if (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string\n\n  let firstBigrams = new Map();\n  for (let i = 0; i < first.length - 1; i++) {\n    const bigram = first.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n    firstBigrams.set(bigram, count);\n  }\n  ;\n  let intersectionSize = 0;\n  for (let i = 0; i < second.length - 1; i++) {\n    const bigram = second.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n    if (count > 0) {\n      firstBigrams.set(bigram, count - 1);\n      intersectionSize++;\n    }\n  }\n  return 2.0 * intersectionSize / (first.length + second.length - 2);\n}\nfunction findBestMatch(mainString, targetStrings) {\n  if (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\n  const ratings = [];\n  let bestMatchIndex = 0;\n  for (let i = 0; i < targetStrings.length; i++) {\n    const currentTargetString = targetStrings[i];\n    const currentRating = compareTwoStrings(mainString, currentTargetString);\n    ratings.push({\n      target: currentTargetString,\n      rating: currentRating\n    });\n    if (currentRating > ratings[bestMatchIndex].rating) {\n      bestMatchIndex = i;\n    }\n  }\n  const bestMatch = ratings[bestMatchIndex];\n  return {\n    ratings: ratings,\n    bestMatch: bestMatch,\n    bestMatchIndex: bestMatchIndex\n  };\n}\nfunction areArgsValid(mainString, targetStrings) {\n  if (typeof mainString !== 'string') return false;\n  if (!Array.isArray(targetStrings)) return false;\n  if (!targetStrings.length) return false;\n  if (targetStrings.find(function (s) {\n    return typeof s !== 'string';\n  })) return false;\n  return true;\n}","map":{"version":3,"names":["module","exports","compareTwoStrings","findBestMatch","first","second","replace","length","firstBigrams","Map","i","bigram","substring","count","has","get","set","intersectionSize","mainString","targetStrings","areArgsValid","Error","ratings","bestMatchIndex","currentTargetString","currentRating","push","target","rating","bestMatch","Array","isArray","find","s"],"sources":["/Users/kamilgeagea/Developer/competitions/conuhacks-client/node_modules/string-similarity/src/index.js"],"sourcesContent":["module.exports = {\n\tcompareTwoStrings:compareTwoStrings,\n\tfindBestMatch:findBestMatch\n};\n\nfunction compareTwoStrings(first, second) {\n\tfirst = first.replace(/\\s+/g, '')\n\tsecond = second.replace(/\\s+/g, '')\n\n\tif (first === second) return 1; // identical or empty\n\tif (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string\n\n\tlet firstBigrams = new Map();\n\tfor (let i = 0; i < first.length - 1; i++) {\n\t\tconst bigram = first.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram) + 1\n\t\t\t: 1;\n\n\t\tfirstBigrams.set(bigram, count);\n\t};\n\n\tlet intersectionSize = 0;\n\tfor (let i = 0; i < second.length - 1; i++) {\n\t\tconst bigram = second.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram)\n\t\t\t: 0;\n\n\t\tif (count > 0) {\n\t\t\tfirstBigrams.set(bigram, count - 1);\n\t\t\tintersectionSize++;\n\t\t}\n\t}\n\n\treturn (2.0 * intersectionSize) / (first.length + second.length - 2);\n}\n\nfunction findBestMatch(mainString, targetStrings) {\n\tif (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\n\t\n\tconst ratings = [];\n\tlet bestMatchIndex = 0;\n\n\tfor (let i = 0; i < targetStrings.length; i++) {\n\t\tconst currentTargetString = targetStrings[i];\n\t\tconst currentRating = compareTwoStrings(mainString, currentTargetString)\n\t\tratings.push({target: currentTargetString, rating: currentRating})\n\t\tif (currentRating > ratings[bestMatchIndex].rating) {\n\t\t\tbestMatchIndex = i\n\t\t}\n\t}\n\t\n\t\n\tconst bestMatch = ratings[bestMatchIndex]\n\t\n\treturn { ratings: ratings, bestMatch: bestMatch, bestMatchIndex: bestMatchIndex };\n}\n\nfunction areArgsValid(mainString, targetStrings) {\n\tif (typeof mainString !== 'string') return false;\n\tif (!Array.isArray(targetStrings)) return false;\n\tif (!targetStrings.length) return false;\n\tif (targetStrings.find( function (s) { return typeof s !== 'string'})) return false;\n\treturn true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}