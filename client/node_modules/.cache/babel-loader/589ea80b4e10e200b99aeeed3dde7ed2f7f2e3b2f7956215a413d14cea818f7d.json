{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n/* global AbortController */\nconst node_fetch_1 = require(\"node-fetch\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst featureDetection_1 = require(\"./featureDetection\");\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\nconst stream_1 = require(\"stream\");\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder, numericEnums) {\n  const fetch = (0, featureDetection_1.hasWindowFetch)() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {\n    // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n    close: () => {\n      return {\n        cancel: () => {}\n      };\n    }\n  };\n  for (const [rpcName, rpc] of Object.entries(rpcs)) {\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      let fetchParameters;\n      try {\n        fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request, numericEnums);\n      } catch (err) {\n        // we could not encode parameters; pass error to the callback\n        // and return a no-op canceler object.\n        callback(err);\n        return {\n          cancel() {}\n        };\n      }\n      const cancelController = (0, featureDetection_1.hasAbortController)() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n      const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: {\n            ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n        if (fetchParameters.method === 'GET' || fetchParameters.method === 'DELETE') {\n          delete fetchRequest['body'];\n        }\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        if (response.ok && rpc.responseStream) {\n          (0, stream_1.pipeline)(response.body, streamArrayParser, err => {\n            if (err && (!cancelRequested || err instanceof Error && err.name !== 'AbortError')) {\n              if (callback) {\n                callback(err);\n              }\n              streamArrayParser.emit('error', err);\n            }\n          });\n          return;\n        } else {\n          return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]).then(_ref => {\n            let [ok, buffer] = _ref;\n            const response = responseDecoder(rpc, ok, buffer);\n            callback(null, response);\n          }).catch(err => {\n            if (!cancelRequested || err.name !== 'AbortError') {\n              if (rpc.responseStream) {\n                if (callback) {\n                  callback(err);\n                }\n                streamArrayParser.emit('error', err);\n              } else {\n                callback(err);\n              }\n            }\n          });\n        }\n      }).catch(err => callback(err));\n      if (rpc.responseStream) {\n        return streamArrayParser;\n      }\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n  return serviceStub;\n}\nexports.generateServiceStub = generateServiceStub;","map":{"version":3,"mappings":"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","names":["generateServiceStub","rpcs","protocol","servicePath","servicePort","authClient","requestEncoder","responseDecoder","numericEnums","fetch","window","node_fetch_1","serviceStub","close","cancel","rpcName","rpc","Object","entries","request","options","_metadata","callback","fetchParameters","err","cancelController","AbortController","abort_controller_1","cancelSignal","signal","cancelRequested","url","headers","key","keys","streamArrayParser","streamArrayParser_1","getRequestHeaders","then","authHeader","fetchRequest","body","method","response","ok","responseStream","Error","name","emit","Promise","all","resolve","arrayBuffer","buffer","catch","abort","exports"],"sources":["../../src/fallbackServiceStub.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}