{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleExecutor = void 0;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst warnings_1 = require(\"../warnings\");\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\nconst task_1 = require(\"./task\");\nfunction noop() {}\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\nclass BundleExecutor {\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  constructor(bundleOptions, bundleDescriptor) {\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n  schedule(apiCall, request, callback) {\n    const bundleId = (0, bundlingUtils_1.computeBundleId)(request, this._descriptor.requestDiscriminatorFields);\n    callback = callback || noop;\n    if (bundleId === undefined) {\n      (0, warnings_1.warn)('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + `Invoking immediately. Request: ${JSON.stringify(request)} ` + `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n      return apiCall(request, callback);\n    }\n    if (request[this._descriptor.bundledField] === undefined) {\n      (0, warnings_1.warn)('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` + `Invoking immediately. Request: ${JSON.stringify(request)}`);\n      return apiCall(request, callback);\n    }\n    if (!(bundleId in this._tasks)) {\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n    }\n    let task = this._tasks[bundleId];\n    callback.id = String(this._invocationId++);\n    this._invocations[callback.id] = bundleId;\n    const bundledField = request[this._descriptor.bundledField];\n    const elementCount = bundledField.length;\n    let requestBytes = 0;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    bundledField.forEach(obj => {\n      requestBytes += this._descriptor.byteLengthFunction(obj);\n    });\n    const countLimit = this._options.elementCountLimit || 0;\n    const byteLimit = this._options.requestByteLimit || 0;\n    if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n      let message;\n      if (countLimit > 0 && elementCount > countLimit) {\n        message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n      } else {\n        message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n      }\n      const error = new googleError_1.GoogleError(message);\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n      return {\n        cancel: noop\n      };\n    }\n    const existingCount = task.getElementCount();\n    const existingBytes = task.getRequestByteSize();\n    if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n      this._runNow(bundleId);\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      task = this._tasks[bundleId];\n    }\n    task.extend(bundledField, requestBytes, callback);\n    const ret = {\n      cancel() {\n        self._cancel(callback.id);\n      }\n    };\n    const countThreshold = this._options.elementCountThreshold || 0;\n    const sizeThreshold = this._options.requestByteThreshold || 0;\n    if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n      this._runNow(bundleId);\n      return ret;\n    }\n    if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n      this._timers[bundleId] = setTimeout(() => {\n        delete this._timers[bundleId];\n        this._runNow(bundleId);\n      }, this._options.delayThreshold);\n    }\n    return ret;\n  }\n  /**\n   * Clears scheduled timeout if it exists.\n   *\n   * @param {String} bundleId - the id for the task whose timeout needs to be\n   *   cleared.\n   * @private\n   */\n  _maybeClearTimeout(bundleId) {\n    if (bundleId in this._timers) {\n      const timerId = this._timers[bundleId];\n      delete this._timers[bundleId];\n      clearTimeout(timerId);\n    }\n  }\n  /**\n   * Cancels an event.\n   *\n   * @param {String} id - The id for the event in the task.\n   * @private\n   */\n  _cancel(id) {\n    if (!(id in this._invocations)) {\n      return;\n    }\n    const bundleId = this._invocations[id];\n    if (!(bundleId in this._tasks)) {\n      return;\n    }\n    const task = this._tasks[bundleId];\n    delete this._invocations[id];\n    if (task.cancel(id)) {\n      this._maybeClearTimeout(bundleId);\n      delete this._tasks[bundleId];\n    }\n  }\n  /**\n   * Invokes a task.\n   *\n   * @param {String} bundleId - The id for the task.\n   * @private\n   */\n  _runNow(bundleId) {\n    if (!(bundleId in this._tasks)) {\n      (0, warnings_1.warn)('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n      return;\n    }\n    this._maybeClearTimeout(bundleId);\n    const task = this._tasks[bundleId];\n    delete this._tasks[bundleId];\n    task.run().forEach(id => {\n      delete this._invocations[id];\n    });\n  }\n}\nexports.BundleExecutor = BundleExecutor;","map":{"version":3,"mappings":"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","names":["noop","BundleExecutor","constructor","bundleOptions","bundleDescriptor","_options","_descriptor","_tasks","_timers","_invocations","_invocationId","schedule","apiCall","request","callback","bundleId","requestDiscriminatorFields","undefined","JSON","stringify","bundledField","task_1","subresponseField","task","id","String","elementCount","length","requestBytes","self","forEach","obj","byteLengthFunction","countLimit","elementCountLimit","byteLimit","requestByteLimit","message","error","googleError_1","code","status_1","INVALID_ARGUMENT","cancel","existingCount","getElementCount","existingBytes","getRequestByteSize","_runNow","extend","ret","_cancel","countThreshold","elementCountThreshold","sizeThreshold","requestByteThreshold","delayThreshold","setTimeout","_maybeClearTimeout","timerId","clearTimeout","run","exports"],"sources":["../../../src/bundlingCalls/bundleExecutor.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}